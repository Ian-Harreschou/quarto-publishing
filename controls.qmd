---
title: Process Simulation & Control

toc: true
toc-location: left
toc-title: Contents

# number-sections: true
# number-depth: 2

execute:
    enabled: true
    freeze: false

format:
    html:
        code-fold: true
        math: mathjax

jupyter: py_controls
---

---

## Bode and Root Locus Diagrams of LTI Systems {.unlisted}

This demonstration takes advantage of the `python-control` package, which implements basic operations for modeling control systems. Find the documentation for an installation guide and tutorials [here](https://python-control.readthedocs.io/en/0.10.2/index.html).

---

```{python}
# preamble to import packages (renamed using 'import <package> as <name>')
import numpy as np
import control as ctrl
import matplotlib.pyplot as plt
```

### Constructing Transfer Functions

Before we look at the behavior of transfer functions, we need to know how to construct them. 

In the `control` package we can do this a number of ways--such as via state-space representation--but one of the most intuitive or beginner-friendly methods is by defining our symbolic $s$, then using standard algebraic operations to build the polynomials of the transfer function $G(s)$. 

`control` includes a "factory function" `tf()` to construct objects of the `TransferFunction` class for this purpose.

```{python}
s = ctrl.tf('s') # define 's' as a TransferFunction class

G = 1 / (2*s + 1)
```

In this code cell, we are constructing 

$$G(s) = \frac{1}{2s + 1}$$

by using standard operations with the derivative operator 's'.

If we wanted to add more information to the transfer function, e.g. a name, or particular tags for inputs/outputs, we can explicitly provide arrays of numbers representing the powers of 's' in the numerator / denominator, then pass additional keywords for namings.

```{python}
num = [2.5, 6, 7]
den = [1, 1.5, 4, 6]

G = ctrl.tf(num, den, name = 'Gc', inputs = ['Ysp'], outputs = ['Y'])
```

This cell constructs a transfer function 

$$G(s) = \frac{2.5s^{2}+6s+7}{s^{3}+1.5s^{2}+4s+6}$$

named explicitly as `Gc`, with input `Ysp` and output `Y`.

---

### Input/Output Responses

Once we've constructed transfer functions from some underlying dynamical system, we're typically interested in how the system responds to perturbations such as impulses or step changes. Again, `control` provides a toolkit for this, namely in the `step_response` function.

Visualizing the step response of 

$$G_{p}(s) = \frac{1}{(s+2)(s+1)}$$

which we expect to be stable (with no oscillations) due to the negative real poles:

```{python}
Gp = 1 / ((s + 2)*(s + 1)) # transfer function for a black-box process, with poles at s = -1, -2

resp = ctrl.step_response(Gp)

resp.plot(plot_inputs=True)
```

---

### Frequency Analysis - Bode Plots

Recall the utility of Bode plots. They are a graphical tool used to visualize how a given transfer function responds to an oscillatory input, of the form,

$$u(t) = A\sin{\omega t + \phi}$$

for a specified amplitude $A$, frequency of oscillation $\omega$, and phase shift $\phi$. The Bode plot shows the magnitude (amplitude ratio) of oscillations that will be observed in the output, as well as the response's phase shift.

These plots quickly show us how "well" the dynamics of our system can keep up with

Consider a transfer function
$$G(s) = \frac{1}{(\tau_{1}s + 1)(\tau_{2}s + 1)}$$

with two poles ($p_{1}, p_{2}$) at $s = -\frac{1}{\tau_{1}}, -\frac{1}{\tau_{2}}$ for $\tau_{1}, \tau_{2} = 1, \ 10$.

```{python}
t1, t2 = 1, 10
G1 = 1 / ((t1*s + 1)*(t2*s + 1))

ctrl.bode_plot(G1)
```

---

### Root Locus Diagrams

Root locus diagrams are graphical tools used to assess the stability of a system as one of its parameters varies -- usually the controller gain $K_c$. Here, we'll look at a few familiar systems from homework. Consider the following open-loop transfer functions, for two systems under PI-control:

$$L_{1}(s) = \frac{\frac{K_{c}}{1.5}(1.5s+1)}{s(2s+1)(s+1)}$$

$$L_{2}(s) = \frac{\frac{K_{c}}{0.5}(0.5s+1)}{s(2s+1)(s+1)}$$

```{python}
Kc = 1 # placeholder gain to use in tf construction

tau_I = 1.5

Gv = 1 # tf of a gate valve (unity loop)
Gm = 1 # tf of a measurement device (unity loop)

Gp = 1 / ((2*s+1)*(s + 1)) # tf of the process
Gc = Kc * (1 + 1 / (tau_I*s)) # tf of the controller

Gol = Gv*Gm*Gp*Gc

ctrl.root_locus_plot(Gol)
```

```{python}

Kc = 1 # placeholder gain to use in tf construction

tau_I = 1.5

Gc = Kc * (1 + 1 / (tau_I*s)) # tf of the controller

Gol = Gv*Gm*Gp*Gc

ctrl.root_locus_plot(Gol)
```

### References