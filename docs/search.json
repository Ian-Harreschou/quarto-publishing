[
  {
    "objectID": "controls.html",
    "href": "controls.html",
    "title": "Process Simulation & Control",
    "section": "",
    "text": "This demonstration takes advantage of the python-control package to illustrate tools available for computational / numerical process modeling and control. This package implements basic operations for modeling control systems. Find the documentation for an installation guide and tutorials here.\n\n\n\nCode\n# preamble to import packages (renamed using 'import &lt;package&gt; as &lt;name&gt;')\nimport numpy as np\nimport control as ctrl\nimport matplotlib.pyplot as plt\n\n\n\nConstructing Transfer Functions\nBefore we look at the behavior of transfer functions, we need to know how to construct them.\nIn the control package we can do this a number of ways–such as via state-space representation–but one of the most intuitive or beginner-friendly methods is by defining our symbolic \\(s\\), then using standard algebraic operations to build the polynomials of the transfer function \\(G(s)\\).\ncontrol includes a “factory function” tf() to construct objects of the TransferFunction class for this purpose.\n\n\nCode\ns = ctrl.tf('s') # define 's' as a TransferFunction class\n\nG = 1 / (2*s + 1)\n\n\nIn this code cell, we are constructing\n\\[G(s) = \\frac{1}{2s + 1}\\]\nby using standard operations with the derivative operator ‘s’.\nIf we wanted to add more information to the transfer function, e.g. a name, or particular tags for inputs/outputs, we can explicitly provide arrays of numbers representing the powers of ‘s’ in the numerator / denominator, then pass additional keywords for namings.\n\n\nCode\nnum = [2.5, 6, 7]\nden = [1, 1.5, 4, 6]\n\nG = ctrl.tf(num, den, name = 'Gc', inputs = ['Ysp'], outputs = ['Y'])\n\n\nThis cell constructs a transfer function\n\\[G(s) = \\frac{2.5s^{2}+6s+7}{s^{3}+1.5s^{2}+4s+6}\\]\nnamed explicitly as Gc, with input Ysp and output Y.\n\n\n\nInput/Output Responses\nOnce we’ve constructed transfer functions from some underlying dynamical system, we’re typically interested in how the system responds to perturbations such as impulses or step changes.\nIf the system is stable, the time-domain response will settle. This could be to its original steady-state, in the case we have an impulse input, a new steady-state if we provide a step-change, or it may never settle if we provide a ramp input.\nAgain, control provides tools for this analysis, with the step_response, impulse_response, and forced_response functions.\n\nImpulse Response\n\n\nCode\nGp = 1 / ((s + 2)*(s + 1)) # transfer function for a black-box process, with poles at s = -1, -2\n\nresp = ctrl.impulse_response(Gp)\n\nresp.plot(plot_inputs='overlay', legend_map = ['upper left'], label = [f'$y(t)$', f'$u(t) = \\\\delta(t)$'])\n\n\n\n\n\n\n\n\n\n\n\nStep Response\n\n\nCode\nGp = 1 / ((s + 2)*(s + 1)) # transfer function for a black-box process, with poles at s = -1, -2\n\nresp = ctrl.step_response(Gp)\n\nresp.plot(plot_inputs='overlay', legend_map = ['upper left'], label = [f'$y(t)$', f'$u(t) = 1$'])\n\n\n\n\n\n\n\n\n\n\n\nForced Response\n\n\nCode\nGp = 1 / ((s + 2)*(s + 1)) # transfer function for a black-box process, with poles at s = -1, -2\nt = np.linspace(0, 7, num=300)\n\nresp = ctrl.forced_response(Gp, t, t)\n\nresp.plot(plot_inputs='overlay', legend_map = ['upper left'], label = [f'$y(t)$', f'$u(t) = t$'])\n\n\n\n\n\n\n\n\n\n\n\n\n\nFrequency Analysis - Bode Plots\nRecall the utility of Bode plots. They are a graphical tool used to visualize how a given transfer function responds to an oscillatory input, of the form,\n\\[u(t) = A\\sin{\\omega t + \\phi}\\]\nfor a specified amplitude \\(A\\), frequency of oscillation \\(\\omega\\), and phase shift \\(\\phi\\). The Bode plot shows the magnitude (amplitude ratio) of oscillations that will be observed in the output, as well as the response’s phase shift.\nThese plots quickly show us how “well” the dynamics of our system can keep up with\nConsider a transfer function \\[G(s) = \\frac{1}{(\\tau_{1}s + 1)(\\tau_{2}s + 1)}\\]\nwith two poles (\\(p_{1}, p_{2}\\)) at \\(s = -\\frac{1}{\\tau_{1}}, -\\frac{1}{\\tau_{2}}\\) for \\(\\tau_{1}, \\tau_{2} = 1, \\ 10\\).\n\n\nCode\nt1, t2 = 1, 10\nG1 = 1 / ((t1*s + 1)*(t2*s + 1))\n\nctrl.bode_plot(G1)\n\n\n\n\n\n\n\n\n\n\n\n\nRoot Locus Diagrams\nRoot locus diagrams are graphical tools used to assess the stability of a system as one of its parameters varies – usually the controller gain \\(K_c\\). Here, we’ll look at a few familiar systems from homework. Consider the following open-loop transfer functions, for two systems under PI-control:\n\\[L_{1}(s) = \\frac{\\frac{K_{c}}{1.5}(1.5s+1)}{s(2s+1)(s+1)}\\]\n\\[L_{2}(s) = \\frac{\\frac{K_{c}}{0.5}(0.5s+1)}{s(2s+1)(s+1)}\\]\n\n\nCode\nKc = 1 # placeholder gain to use in tf construction\n\ntau_I = 1.5\n\nGv = 1 # tf of a gate valve (unity loop)\nGm = 1 # tf of a measurement device (unity loop)\n\nGp = 1 / ((2*s+1)*(s + 1)) # tf of the process\nGc = Kc * (1 + 1 / (tau_I*s)) # tf of the controller\n\nGol = Gv*Gm*Gp*Gc\n\nctrl.root_locus_plot(Gol)\n\n\nIgnoring fixed x limits to fulfill fixed data aspect with adjustable data limits.\n\n\n\n\n\n\n\n\n\n\n\nCode\nKc = 1 # placeholder gain to use in tf construction\n\ntau_I = 1.5\n\nGc = Kc * (1 + 1 / (tau_I*s)) # tf of the controller\n\nGol = Gv*Gm*Gp*Gc\n\nctrl.root_locus_plot(Gol)\n\n\nIgnoring fixed x limits to fulfill fixed data aspect with adjustable data limits.\n\n\n\n\n\n\n\n\n\n\n\nReferences"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to my Quarto site",
    "section": "",
    "text": "This is a hub for personal notes and tutorials in process simulation and control, (…). They closely follow courses taken at the University of Minnesota - Twin Cities.\nUse the navigation bar to explore other topics.\n\nDisclaimer\nThe materials and examples on this site are provided for informational and educational purposes only. They are not intended for commercial, industrial, or research use, and no guarantee is made regarding their accuracy, completeness, or suitability for any specific application. All computations, simulations, and software demonstrations are illustrative in nature and should be verified independently before use in any real-world context."
  },
  {
    "objectID": "reactors.html",
    "href": "reactors.html",
    "title": "Test Publishing to GitHub Pages with Quarto (Page 2)",
    "section": "",
    "text": "Code\nx = 2\nprint(x)\n\n\n2"
  }
]