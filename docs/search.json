[
  {
    "objectID": "control-plotting.html",
    "href": "control-plotting.html",
    "title": "Plotting Functionalities",
    "section": "",
    "text": "This demonstration takes advantage of the python-control package to illustrate tools available for computational / numerical process modeling and control. This package implements basic operations for modeling linear, time-invariant (as well as nonlinear, discrete, and stochastic) control systems. Find the documentation for an installation guide and tutorials here.\\(^{[1]}\\)\nCode\n# preamble to import packages (renamed using 'import &lt;package&gt; as &lt;name&gt;')\nimport numpy as np\nimport control as ctrl\nimport matplotlib.pyplot as plt\nimport warnings\n\nfrom IPython.display import Markdown, display # to make HTML/Markdown play nicer\n\nwith warnings.catch_warnings():\n    warnings.filterwarnings(\"ignore\", message=\"Ignoring fixed x limits\")\n    warnings.filterwarnings(\"ignore\", message=\"Ignoring fixed y limits to fulfill fixed data aspect with adjustable data limits.\")",
    "crumbs": [
      "Home",
      "Plotting Functionalities"
    ]
  },
  {
    "objectID": "control-plotting.html#common-graphical-techniques",
    "href": "control-plotting.html#common-graphical-techniques",
    "title": "Plotting Functionalities",
    "section": "Common Graphical Techniques",
    "text": "Common Graphical Techniques\nWe’ll jump right in with some high-level plotting functionalities that control provides, namely in generating Bode plots and root locus diagrams.\n\n\nFrequency Analysis - Bode Plots\nRecall the utility of Bode plots. They are a graphical tool used to visualize how a given transfer function responds to an oscillatory input, of the form,\n\\[u(t) = A\\sin({\\omega t + \\phi})\\]\nfor a specified amplitude \\(A\\), frequency \\(\\omega\\), and phase shift \\(\\phi\\). The Bode plot shows the magnitude (amplitude ratio) of oscillations that will be observed in the output, as well as the response’s phase shift.\nThese plots quickly show us how “well” the dynamics of our system can keep up with this sinusoidal input, as a function of the incoming frequency of oscillation\nConsider a transfer function \\[G(s) = \\frac{1}{(\\tau_{1}s + 1)(\\tau_{2}s + 1)}\\]\nwith two poles \\(p_{1}, p_{2}\\) at \\(s = -\\frac{1}{\\tau_{1}}, -\\frac{1}{\\tau_{2}}\\) for \\(\\tau_{1}, \\tau_{2} = 1, \\ 10\\).\nWith the transfer function properly constructed, we need only to call control.bode_plot() on it for a quick Bode diagram.\n\n\nCode\ns = ctrl.tf('s') # define 's' as a TransferFunction class\n\nt1, t2 = 1, 10\nG1 = 1 / ((t1*s + 1)*(t2*s + 1))\n\nctrl.bode_plot(G1)\n\n\n\n\n\n\n\n\n\nAt this point, we’ve seen and approximated many Bode plots. The key takeaways are:\n\nthe amplitude ratio represents the ratio of the output signal’s frequency to that of the input signal.\n\nOnce we reach a frequency where \\(AR &lt; 1\\), then the output signal becomes more and more attenuated as we continue to increase frequency.\nThe input begins oscillating so quickly that the output isn’t able to fully reach any maxima of the input\n\nthis is precisely the filtering effect we’ve discussed in the context of surge tanks that smooth incoming fluctuations in flowrate.\n\n\nthe phase shift stems from the finite dynamics of the process, sensor, control elements, etc. The overall system can’t instantaneously respond to the input, and this manifests as a delay\n\nThe delay is a function of frequency, and it’s not just a constant shift that we would see in a system with delay time, e.g. \\(G(s) \\propto \\exp^{-\\tau_d s}\\). Certain incoming frequencies are shifted less, and others more.\nWe care about the conditions under which we cross \\(-180^{\\circ}\\) because at that point, our output signal is completely inverted relative to the input – maxima in input become minima in the output, which can be a problem for feedback schemes (depending on the magnitude at that point)!\n\n\n\n\n\nRoot Locus Diagrams\nRoot locus diagrams are graphical tools used to assess the stability of a system as one of its parameters is varried, usually the controller gain \\(K_c\\).\nHere, we’ll look at one system from homework. Consider the following open-loop transfer function (HW#7):\n\\[L(s) = G_v G_c G_p G_m = K_{c} \\Big( 1 + \\frac{1}{\\tau_I s} \\Big) \\frac{1}{(\\tau_1 s + 1)(\\tau_2 s + 1)}\\]\nfor \\(\\tau_I = \\frac{1}{2}, \\tau_1, \\tau_2 = 1, 2\\).\nWe can then form the closed-loop response, and since it’s assumed to be a unity feedback loop (\\(G_v = G_m = 1\\)), then it collapses into a neater form:\n\\[G_{CL}(s) = \\frac{L(s)}{1 + L(s)}\\]\n\\[G_{CL}(s) = \\frac{G_v G_c G_p}{1 + G_v G_c G_p G_m} = \\frac{K_{c} \\Big( 1 + \\frac{1}{\\tau_I s} \\Big) \\frac{1}{(\\tau_1 s + 1)(\\tau_2 s + 1)}}{1 + K_{c} \\Big( 1 + \\frac{1}{\\tau_I s} \\Big) \\frac{1}{(\\tau_1 s + 1)(\\tau_2 s + 1)}}\\]\nThis closed-loop had poles at \\(s = 0, -1, -\\frac{1}{2}\\), a zero at \\(s = -2\\), a centroid at \\(\\sigma = \\frac{1}{4}\\), and the breakaway was \\(s \\approx -0.23\\)\nIt’s then straightforward to generate an initial root-locus diagram using control.root_locus_plot()!\n\n\nCode\nKc = 1 # placeholder gain to use in tf construction\n\nt1, t2 = 1, 2; # time constants in the process and for measurement\ntI = 1/2 # integral time constant\n\nGv = 1;\nGm = 1;\n\nGp = 1 / ((t1*s + 1)*(t2*s + 1))\nGc = Kc * (1 + 1 / (tI*s))\n\nL = Gv * Gc * Gp * Gm;\n\nctrl.root_locus_plot((Gv * Gp * Gc) / (1 + L), grid = False, xlim = (-2.5, 1.5), ylim = (-3, 3));\n\n\nIgnoring fixed x limits to fulfill fixed data aspect with adjustable data limits.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nWait! It appears some features are missing, such as the trajectories of the poles \\(p_1 = 0, p_2 = -\\frac{1}{2}\\) as they breakaway from the Re-axis and start diverging toward the Im-axis…\n\n\nNumerical routines such as the root-finding needed to generate a root-locus diagram are sensitive to numerical precision. Also, generating a diagram for a complex closed-loop transfer function is going to be inherently more complicated than a rather simple function, so key features might be missed by whichever algorithms the code developer included to be used by default.\nIn the above scenario, you can increase the range of controller gains used in the calculations to capture the breakaway trajectories better, but this doesn’t seem to work directly with the control.root_locus_plot() function. It’s times like these where by-hand approximations are sometimes the more robust approach!\n\n\n\nPhase and Gain Margins\nPhase and gain margins are quantitative measures of relative stability of closed-loop systems, or their ‘robustness’ to model uncertainty and process variation.\\(^{[2]}\\)\nThese quantities essentially tell us how far away from marginal stability the system is, so that we can integrate some semblance of safety into operations.\nQuickly, we will review a few definitions, and then introduce the newer ones.\n\n(Open) Loop transfer function \\(L(s)\\) – the product of the controller transfer function \\(G_c(s)\\) with an overall process transfer function \\(G(s)\\) (which typically includes the physical process, any sensors/measurement devices, and control elements such as valves).\n\n\\[L(s) = G_c(s)G_v(s)G_p(s)G_m(s) = G_c(s)G(s)\\]\n\nMarginal stability – the point at which we observe sustained (non-decaying) oscillations in our output, when the input to the system is a sinusoidal function. \\[1 + L(s=i \\omega_u) = 0\\]\n\nOr,\n\\[L(s = i \\omega_u) = -1\\]\nfor an “ultimate” value of \\(K_c = K_{cu}, \\omega = \\omega_{u}\\), above which we become unstable, as the poles will begin moving into the right half of the Re-Im plane.\n\nPhase crossover (or critical) frequency \\(\\omega_p\\) – the frequency at which the phase of the loop transfer function becomes equal to \\(-180 ^{\\circ}\\).\n\n\\[ \\omega_p : \\angle {L(i \\omega_p)} = -180 ^{\\circ}\\]\n\nGain crossover frequency \\(\\omega_g\\) – the frequency at which the magnitude of \\(L(s)\\) becomes equal to one,\n\n\\[ \\omega_g : |L(i\\omega_g)|=1\\]\nWith these, we can introduce the phase and gain margins.\n\nPhase margin PM – the phase shift of the loop transfer function at \\(\\omega_g\\) necessary to cause the system to reach marginal stability.\n\nAnother interpretation is the distance on the phase diagram between the current phase shift and \\(-180^{\\circ}\\).\n\\[PM = \\arg \\big \\{ L(i \\omega_g) \\big \\} - (-180^{\\circ})\\]\n\nGain margin GM – the factor by which we can scale/multiply the controller gain before the onset of instability\n\n\\[GM = \\frac{1}{|L(i \\omega_p)|}\\]\n\n\n\n\n\n\nNote\n\n\n\nIncreasing \\(K_c\\) shifts the amplitude ratio of our transfer function upward on a Bode diagram, while leaving the phase shift unchanged. The opposite is true for a system with time delay; the phase shift will necessarily change, but the magnitude will be left unmodified!\n\n\nA high gain margin corresponds to a system that is far away from instability, but there is a tradeoff, as our controller responds sluggishly.\nA large phase margin is also a sign that the system is far from instability – there is a safety margin for how much time delay the system can handle before seeing sustained (or worse, growing) oscillations in the output.\n\n\nExample1\nAs an illustration of these quantities, take the following PI- controller, aiming to control some 3rd order process:\n\\[G(s) = \\frac{K}{(\\tau_1s + 1)(\\tau_2s + 1)(\\tau_3s+1)}\\]\nfor \\(\\tau_1, \\tau_2, \\tau_3 = 1, 1/2, 1/3\\).\nOur controller has both P- and I-action, which will look like: \\[G_c(s) = K_c (1 + \\frac{1}{\\tau_I s})\\]\nwith a chosen value of \\(\\tau_I = 1/3\\).\nWe are told the product of our process and controller gains are non-zero, e.g. \\(K_c K &gt; 0\\), and from a previous example we want to look at the case where \\(K_c K = 0.5\\)\nThe corresponding Bode plot is the following:\n\n\nCode\nK = 1 # loop transfer function (process) gain\nKc = 0.5 # controller gain\n\nt1, t2, t3 = 1, 1/2, 1/3\ntI = 1/3\n\nG = K / ((t1*s + 1)*(t2*s + 1)*(t3*s+1))\nGc = Kc * (1 + 1/(tI*s))\n\nL = Gc * G\n\ngm, pm, sm, wpc, wgc, wms = ctrl.stability_margins(L)\n\nctrl.bode_plot(L)\n\n\n\n\n\n\n\n\n\n\n\nCode\ntable_md = f\"\"\"\n| Parameter | Value |\n|:---------:|:-----:|\n| $\\\\omega_{{pc}}$ | {wpc:.3f} |\n| $\\\\omega_{{gc}}$ | {wgc:.3f} |\n| $GM$            | {gm:.3f}  |\n| $PM$            | {pm:.1f}° |\n\"\"\"\n\ndisplay(Markdown(table_md))\n\n\n\n\n\nParameter\nValue\n\n\n\n\n\\(\\omega_{pc}\\)\n1.414\n\n\n\\(\\omega_{gc}\\)\n0.969\n\n\n\\(GM\\)\n2.000\n\n\n\\(PM\\)\n20.0°\n\n\n\n\n\nSince both of these quantities are geometric in nature (i.e. they’re distances), they can be visualized on our Bode plot as well, meaning we could estimate them fairly accurately with a well-drawn diagram.\n\n\n\nFigure 17.7 of Ch 17.2, illustrating the gain and phase margins of the same open-loop function in the above example, overtop its Bode diagram. Both definitions use the two crossover frequencies \\(\\omega_g\\) and \\(\\omega_p\\) as anchor points.\\(^{[2]}\\)\n\n\nThe next question to ask after all this might be: Do we expect the fully-connected, closed-loop response to be step-stable? What might the “output” look like when we simulate a step input?\n\n\n\n\n\n\nImportant\n\n\n\nThe poles of our \\(L(s)\\) are purely real, and lie in the left-hand portion of the Re-Im plane.\n\n\nTaking our open-loop transfer function, \\[ L(s) = (1 + \\frac{1}{\\tau_I s}) \\frac{K_c K}{(\\tau_1s + 1)(\\tau_2s + 1)(\\tau_3s+1)} \\]\n\\[ = (\\tau_I s + 1) \\frac{K_c K}{(\\tau_I s)(\\tau_1s + 1)(\\tau_2s + 1)(\\tau_3s+1)} \\]\nif we have a standard unity feedback loop, the closed-loop response to a change in setpoint will be\n\\[G_{CL,sp} = \\frac{L(s)}{1 + L(s)}\\]\nand for a step input, we see the following behavior.\n\n\nCode\nt = np.linspace(0,25,num=100)\n\nresp = ctrl.step_response(L / (1 + L), t)\n\nresp.plot(plot_inputs='overlay', legend_map = ['upper left'], label = [f'$G_CL(t)$', f'$u(t) = M(t)$'])\n\n\n\n\n\n\n\n\n\nAs we might expect, there’s an initial overshoot, oscillation about the step value, and then the system settles to our setpoint with no steady-state error.\nNow, let’s make use the calculated gain and phase margins to push this system to the brink of instability to confirm the behavior is as we expect!\nIn this scenario, \\((K_c K)_{new} = GM(K_c K)_{old}\\)\n\n\nCode\nt = np.linspace(0,25,num=100)\n\nL = L * gm # scale the original loop transfer function by the previously calculated gain margin\n\nresp = ctrl.step_response(L / (1 + L), t)\n\nresp.plot(plot_inputs='overlay', legend_map = ['upper left'], label = [f'$G_CL(t)$', f'$u(t) = M(t)$'])\n\ngm, pm, sm, wpc, wgc, wms = ctrl.stability_margins(L)\n\n\n\n\n\n\n\n\n\n\n\nCode\ntable_md = f\"\"\"\n| Parameter | Value |\n|:---------:|:-----:|\n| $\\\\omega_{{pc}}$ | {wpc:.3f} |\n| $\\\\omega_{{gc}}$ | {wgc:.3f} |\n| $GM$            | {gm:.3f}  |\n| $PM$            | {pm:.1f}° |\n\"\"\"\n\ndisplay(Markdown(table_md))\n\n\n\n\n\nParameter\nValue\n\n\n\n\n\\(\\omega_{pc}\\)\n1.414\n\n\n\\(\\omega_{gc}\\)\n1.414\n\n\n\\(GM\\)\n1.000\n\n\n\\(PM\\)\n0.0°\n\n\n\n\n\nIn this response, we see non-decaying oscillations since our poles have been pushed such that they interesct the Im-axis, meaning now there is persistent steady-state error.\nNotice in this table, that the phase crossover frequency \\(w_{pc}\\) did not change (indicating the phase shift of the system was unmodified), yet the gain crossover frequency \\(w_{gc}\\) did! Additionally, these two are coincident at \\(\\omega = \\sqrt(2)\\)\nWe see that \\(GM = 1\\), \\(PM = 0^{\\circ}\\), indicating the gains shouldn’t be scaled further, and the system can’t handle any more time delay before becoming unstable.\n\n\n\n\n\n\nNote\n\n\n\nReiterating, \\(PM\\) is how far the system is from realizing a phase shift of \\(-180^{\\circ}\\) (or a complete inverse of the incoming signal) for a given input frequency. This has implications on the stability of a feedback loop in which we use the output / measurement to inform controller action!\n\n\nFinally, just to hit the concepts home, we’ll simulate what happens when we increase the gains even further, despite having no wiggle room.\n\n\nCode\nt = np.linspace(0,25,num=100)\n\nL = L * (gm+0.05) # scale the loop transfer function by the gain margin plus some small value\n\nresp = ctrl.step_response(L / (1 + L), t)\n\nresp.plot(plot_inputs='overlay', legend_map = ['upper left'], label = [f'$G_CL(t)$', f'$u(t) = M(t)$'])\n\ngm, pm, sm, wpc, wgc, wms = ctrl.stability_margins(L)\n\n\n\n\n\n\n\n\n\n\n\nCode\ntable_md = f\"\"\"\n| Parameter | Value |\n|:---------:|:-----:|\n| $\\\\omega_{{pc}}$ | {wpc:.3f} |\n| $\\\\omega_{{gc}}$ | {wgc:.3f} |\n| $GM$            | {gm:.3f}  |\n| $PM$            | {pm:.1f}° |\n\"\"\"\n\ndisplay(Markdown(table_md))\n\n\n\n\n\nParameter\nValue\n\n\n\n\n\\(\\omega_{pc}\\)\n1.414\n\n\n\\(\\omega_{gc}\\)\n1.449\n\n\n\\(GM\\)\n0.952\n\n\n\\(PM\\)\n-1.3°\n\n\n\n\n\nSince we’ve pushed the gains of the system and controller too far, we’ve interesct with and crossed over the imaginary axis, pushing the poles into the right-half of the Re-Im plane.\nAt this point, our gain margin is a factor less than 1, telling us we need to backoff the controller gain to once again reach a stable system. Our phase margin is also negative, which is not a good sign either.\nIn a real-world situation, this can lead to serious safety hazards, or at the very least damage to control infrastructure such as valves, by way of rapidly opening and closing them (to an ever-increasing degree)!",
    "crumbs": [
      "Home",
      "Plotting Functionalities"
    ]
  },
  {
    "objectID": "control-plotting.html#references",
    "href": "control-plotting.html#references",
    "title": "Plotting Functionalities",
    "section": "References",
    "text": "References\n[1] S. Fuller, B. Greiner, J. Moore, R. Murray, R. van Paassen and R. Yorke, “The Python Control Systems Library (python-control),” 2021 60th IEEE Conference on Decision and Control (CDC), 2021, pp. 4875-4881\n[2] Kravaris, C., & Kookos, I. K. (2021). Understanding Process Dynamics and Control. Cambridge University Press.",
    "crumbs": [
      "Home",
      "Plotting Functionalities"
    ]
  },
  {
    "objectID": "control-plotting.html#footnotes",
    "href": "control-plotting.html#footnotes",
    "title": "Plotting Functionalities",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee Kravaris & Kookos, Ch. 17.2, Example 17.4, “PM and GM of a third-order system under PI control”.↩︎",
    "crumbs": [
      "Home",
      "Plotting Functionalities"
    ]
  },
  {
    "objectID": "control-basics.html",
    "href": "control-basics.html",
    "title": "Core Functionalities",
    "section": "",
    "text": "This demonstration takes advantage of the python-control package to illustrate tools available for computational / numerical process modeling and control. This package implements basic operations for modeling linear, time-invariant (as well as nonlinear, discrete, and stochastic) control systems. Find the documentation for an installation guide and tutorials here.\\(^{[1]}\\)\nCode\n# preamble to import packages (renamed using 'import &lt;package&gt; as &lt;name&gt;')\nimport numpy as np\nimport control as ctrl\nimport matplotlib.pyplot as plt\nimport warnings\n\nfrom IPython.display import Markdown, display # to make HTML/Markdown play nicer\n\nwith warnings.catch_warnings():\n    warnings.filterwarnings(\"ignore\", message=\"Ignoring fixed x limits\")",
    "crumbs": [
      "Home",
      "Core Functionalities"
    ]
  },
  {
    "objectID": "control-basics.html#core-functionalities-of-python-control",
    "href": "control-basics.html#core-functionalities-of-python-control",
    "title": "Core Functionalities",
    "section": "Core Functionalities of Python-Control",
    "text": "Core Functionalities of Python-Control\nIn order to do these simulations, the first step is learning how to actually construct transfer functions using the various machinery offered via the package.\n\n\nConstructing Transfer Functions\nBefore we look at the behavior of transfer functions, we need to know how to construct them.\nIn the control package we can do this a number of ways–such as via state-space representation–but one of the most intuitive or beginner-friendly methods is by defining our symbolic \\(s\\), then using standard algebraic operations to build the polynomials of the transfer function \\(G(s)\\).\ncontrol includes a “factory function” tf() to construct objects of the TransferFunction class for this purpose.\n\n\nCode\ns = ctrl.tf('s') # define 's' as a TransferFunction class\n\nG = 1 / (2*s + 1)\n\n\nIn this code cell, we are constructing\n\\[G(s) = \\frac{1}{2s + 1}\\]\nby using standard operations with the derivative operator ‘s’.\nIf we wanted to add more information to the transfer function, e.g. a name, or particular tags for inputs/outputs, we can explicitly provide arrays of numbers representing the powers of ‘s’ in the numerator / denominator, then pass additional keywords for namings.\n\n\nCode\nnum = [2.5, 6, 7]\nden = [1, 1.5, 4, 6]\n\nG = ctrl.tf(num, den, name = 'Gc', inputs = ['Ysp'], outputs = ['Y'])\n\n\nThis cell constructs a transfer function\n\\[G(s) = \\frac{2.5s^{2}+6s+7}{s^{3}+1.5s^{2}+4s+6}\\]\nnamed explicitly as Gc, with input Ysp and output Y.\n\n\n\nInput/Output Responses\nOnce we’ve constructed transfer functions from some underlying dynamical system, we’re typically interested in how the system responds to perturbations such as impulses or step changes.\nIf the system is stable, the time-domain response will settle. This could be to its original steady-state, in the case we have an impulse input, a new steady-state if we provide a step-change, or it may never settle if we provide a ramp input.\nAgain, control provides tools for this analysis, with the step_response, impulse_response, and forced_response functions.\n\n\nImpulse Response\nConsider an impulse signal at \\(t_{0}=0\\) of size 1, such that our input \\(u(t)=\\delta(t)\\):\n\n\nCode\nGp = 1 / ((s + 2)*(s + 1)) # transfer function for a black-box process, with poles at s = -1, -2\n\nresp = ctrl.impulse_response(Gp)\n\nresp.plot(plot_inputs='overlay', legend_map = ['upper left'], label = [f'$y(t)$', f'$u(t) = \\\\delta(t)$'])\n\n\n\n\n\n\n\n\n\nNote: Plotting a delta function doesn’t make a ton of sense by its definition, so \\(u(t)\\) plotted in red here is not accurate. We’d need to make a special graphic or function to plot it true-to-form…\n\n\n\nStep Response\nHow will the system respond to a constant step input of the form \\(u(t) = M\\), with \\(M = 1\\):\n\n\nCode\nGp = 1 / ((s + 2)*(s + 1)) # transfer function for a black-box process, with poles at s = -1, -2\n\nresp = ctrl.step_response(Gp)\n\nresp.plot(plot_inputs='overlay', legend_map = ['upper left'], label = [f'$y(t)$', f'$u(t) = 1$'])\n\n\n\n\n\n\n\n\n\nNotice, with this form of transfer function, our system never reaches the value of the step input, giving us a non-zero steady-state offset(generally undesirable) and persistent error.\n\n\n\nForced Response\nWe can also simulate how the process will respond to an arbitrary input, i.e. a ramp forcing function \\(u(t) = t\\):\n\n\nCode\nGp = 1 / ((s + 2)*(s + 1)) # transfer function for a black-box process, with poles at s = -1, -2\nt = np.linspace(0, 7, num=300)\n\nresp = ctrl.forced_response(Gp, t, t)\n\nresp.plot(plot_inputs='overlay', legend_map = ['upper left'], label = [f'$y(t)$', f'$u(t) = t$'])\n\n\n\n\n\n\n\n\n\nIn this case, our process is always trying to keep up with the ramp function, but ultimately won’t close the gap. This also yields a non-zero steady-state offset and persistent error, however we might see the system reach a steady-state difference in signals over a long enough time period. Fun, right?",
    "crumbs": [
      "Home",
      "Core Functionalities"
    ]
  },
  {
    "objectID": "control-basics.html#references",
    "href": "control-basics.html#references",
    "title": "Core Functionalities",
    "section": "References",
    "text": "References\n[1] S. Fuller, B. Greiner, J. Moore, R. Murray, R. van Paassen and R. Yorke, “The Python Control Systems Library (python-control),” 2021 60th IEEE Conference on Decision and Control (CDC), 2021, pp. 4875-4881\n[2] Kravaris, C., & Kookos, I. K. (2021). Understanding Process Dynamics and Control. Cambridge University Press.",
    "crumbs": [
      "Home",
      "Core Functionalities"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "This is a hub for course notes and tutorials in process simulation and control. They closely follow courses taken at the University of Minnesota - Twin Cities.\nUse the navigation bar to explore other topics.\n\nDisclaimer\nThe materials and examples on this site are provided for informational and educational purposes only. They are not intended for commercial, industrial, or research use, and no guarantee is made regarding their accuracy, completeness, or suitability for any specific application. All computations, simulations, and software demonstrations are illustrative in nature and should be verified independently before use in any real-world context."
  },
  {
    "objectID": "reactors.html",
    "href": "reactors.html",
    "title": "Test Publishing to GitHub Pages with Quarto (Page 2)",
    "section": "",
    "text": "Code\nx = 2\nprint(x)\n\n\n2"
  }
]