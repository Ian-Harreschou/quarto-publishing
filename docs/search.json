[
  {
    "objectID": "computations.html",
    "href": "computations.html",
    "title": "Test Publishing to GitHub Pages with Quarto",
    "section": "",
    "text": "Example: Simple Matplotlib Plotting\nTake \\(x \\in [0,30]\\) and \\(y_{1} = 2\\sin{x}, y_{2} = 4\\sin{x}\\)\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.arange(30)\ny1 = 2 * np.sin(x)\ny2 = 4 * np.sin(x)\n\nplt.figure()\nplt.ylabel(r'$y$')\nplt.xlabel(r'$x$')\n\nplt.plot(x,y1, label = r\"$y_{1}$\")\nplt.plot(x,y2, label = r\"$y_{2}$\")\n\nplt.legend()"
  },
  {
    "objectID": "reactors.html",
    "href": "reactors.html",
    "title": "Test Publishing to GitHub Pages with Quarto (Page 2)",
    "section": "",
    "text": "Code\nx = 2\nprint(x)\n\n\n2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to my Quarto site",
    "section": "",
    "text": "This is a hub for personal notes and tutorials in process simulation and control, (…). They closely follow courses taken at the University of Minnesota - Twin Cities.\nUse the navigation bar to explore other topics.\n\nDisclaimer\nThe materials and examples on this site are provided for informational and educational purposes only. They are not intended for commercial, industrial, or research use, and no guarantee is made regarding their accuracy, completeness, or suitability for any specific application. All computations, simulations, and software demonstrations are illustrative in nature and should be verified independently before use in any real-world context."
  },
  {
    "objectID": "controls.html#bode-and-root-locus-diagrams-of-lti-systems",
    "href": "controls.html#bode-and-root-locus-diagrams-of-lti-systems",
    "title": "Process Simulation & Control",
    "section": "Bode and Root Locus Diagrams of LTI Systems",
    "text": "Bode and Root Locus Diagrams of LTI Systems\nThis demonstration takes advantage of the python-control package, which implements basic operations for modeling control systems. Find the documentation for an installation guide and tutorials here.\n\n\n\nCode\n# preamble to import packages (renamed using 'import &lt;package&gt; as &lt;name&gt;')\nimport numpy as np\nimport control as ctrl\nimport matplotlib.pyplot as plt\n\n\n\nConstructing Transfer Functions\nBefore we look at the behavior of transfer functions, we need to know how to construct them.\nIn the control package we can do this a number of ways–such as via state-space representation–but one of the most intuitive or beginner-friendly methods is by defining our symbolic \\(s\\), then using standard algebraic operations to build the polynomials of the transfer function \\(G(s)\\).\ncontrol includes a “factory function” tf() to construct objects of the TransferFunction class for this purpose.\n\n\nCode\ns = ctrl.tf('s') # define 's' as a TransferFunction class\n\nG = 1 / (2*s + 1)\n\n\nIn this code cell, we are constructing\n\\[G(s) = \\frac{1}{2s + 1}\\]\nby using standard operations with the derivative operator ‘s’.\nIf we wanted to add more information to the transfer function, e.g. a name, or particular tags for inputs/outputs, we can explicitly provide arrays of numbers representing the powers of ‘s’ in the numerator / denominator, then pass additional keywords for namings.\n\n\nCode\nnum = [2.5, 6, 7]\nden = [1, 1.5, 4, 6]\n\nG = ctrl.tf(num, den, name = 'Gc', inputs = ['Ysp'], outputs = ['Y'])\n\nG\n\n\n&lt;TransferFunction Gc: ['Ysp'] -&gt; ['Y']&gt;\n$$\\dfrac{2.5 s^2 + 6 s + 7}{s^3 + 1.5 s^2 + 4 s + 6}$$\n\n\nThis cell constructs a transfer function\n\\[G(s) = \\frac{2.5s^{2}+6s+7}{s^{3}+1.5s^{2}+4s+6}\\]\nnamed explicitly as Gc, with input Ysp and output Y.\n\n\n\nInput/Output Responses\nOnce we’ve constructed transfer functions from some underlying dynamical system, we’re typically interested in how the system responds to perturbations such as impulses or step changes. Again, control provides a toolkit for this, namely in the step_response function.\nVisualizing the step response of\n\\[G_{p}(s) = \\frac{1}{(s+2)(s+1)}\\]\nwhich we expect to be stable (with no oscillations) due to the negative real poles:\n\n\nCode\nGp = 1 / ((s + 2)*(s + 1)) # transfer function for a black-box process, with poles at s = -1, -2\n\nresp = ctrl.step_response(Gp)\n\nresp.plot(plot_inputs=True)\n\n\n\n\n\n\n\n\n\n\n\nFrequency Analysis - Bode Plots\nRecall the utility of Bode plots. They are a graphical tool used to visualize how a given transfer function responds to an oscillatory input, of the form,\n\\[u(t) = A\\sin{\\omega t + \\phi}\\]\nfor a specified amplitude \\(A\\), frequency of oscillation \\(\\omega\\), and phase shift \\(\\phi\\).\n\n\nCode\nintgr = 1/s\ndiffr = s\n\nctrl.bode_plot(intgr)\n\nctrl.bode_plot(diffr)\n\n\n\n\n\n\n\n\n\n\n\n\nRoot Locus Diagrams\nRoot locus diagrams are graphical tools used to assess the stability of a system as one of its parameters varies – usually the controller gain \\(K_c\\). Here, we’ll look at a few familiar systems from homework. Consider the following open-loop transfer functions, for two systems under PI-control:\n\\[L_{1}(s) = \\frac{\\frac{K_{c}}{1.5}(1.5s+1)}{s(2s+1)(s+1)}\\]\n\\[L_{2}(s) = \\frac{\\frac{K_{c}}{0.5}(0.5s+1)}{s(2s+1)(s+1)}\\]\n\n\nCode\nKc = 1 # placeholder gain to use in tf construction\n\ntau_I = 1.5\n\nGv = 1 # tf of a gate valve (unity loop)\nGm = 1 # tf of a measurement device (unity loop)\n\nGp = 1 / ((2*s+1)*(s + 1)) # tf of the process\nGc = Kc * (1 + 1 / (tau_I*s)) # tf of the controller\n\nGol = Gv*Gm*Gp*Gc\n\nctrl.root_locus_plot(Gol)\n\n\nIgnoring fixed x limits to fulfill fixed data aspect with adjustable data limits.\n\n\n\n\n\n\n\n\n\n\n\nCode\nKc = 1 # placeholder gain to use in tf construction\n\ntau_I = 1.5\n\nGc = Kc * (1 + 1 / (tau_I*s)) # tf of the controller\n\nGol = Gv*Gm*Gp*Gc\n\nctrl.root_locus_plot(Gol)\n\n\nIgnoring fixed x limits to fulfill fixed data aspect with adjustable data limits.\n\n\n\n\n\n\n\n\n\n\n\nReferences"
  }
]